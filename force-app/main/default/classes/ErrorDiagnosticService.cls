/**
 * Service Unifi√© de Diagnostic d'Erreurs avec IA
 * G√®re les erreurs Apex, LWC et Flow de mani√®re coh√©rente
 * Cr√©e un Case avec diagnostic IA, l'email sera envoy√© automatiquement par le Case
 */
public with sharing class ErrorDiagnosticService {
    
    public enum ErrorType {
        APEX, LWC, FLOW
    }
    
    /**
     * Classe wrapper pour les informations d'erreur
     */
    public class ErrorInfo {
        @InvocableVariable(label='Type d\'erreur' required=true)
        public String errorType; // 'APEX', 'LWC', 'FLOW'
        
        @InvocableVariable(label='Nom du composant/flow/classe')
        public String componentName;
        
        @InvocableVariable(label='Message d\'erreur' required=true)
        public String errorMessage;
        
        @InvocableVariable(label='Stack trace')
        public String stackTrace;
        
        @InvocableVariable(label='ID du record d√©clencheur')
        public String recordId;
        
        @InvocableVariable(label='Type d\'objet')
        public String objectType;
        
        // Sp√©cifique Flow
        @InvocableVariable(label='Nom du Flow')
        public String flowName;
        
        @InvocableVariable(label='API Name du Flow')
        public String flowApiName;
        
        @InvocableVariable(label='√âl√©ment en erreur')
        public String faultElement;
        
        // Sp√©cifique Apex
        @InvocableVariable(label='Nom de la classe')
        public String className;
        
        @InvocableVariable(label='Nom de la m√©thode')
        public String methodName;
        
        @InvocableVariable(label='Num√©ro de ligne')
        public Integer lineNumber;
        
        // Sp√©cifique LWC
        @InvocableVariable(label='Code JavaScript')
        public String jsCode;
        
        @InvocableVariable(label='M√©tadonn√©es LWC')
        public String metadata;
        
        // Contexte additionnel (JSON string)
        @InvocableVariable(label='Donn√©es contextuelles (JSON)')
        public String contextData;
    }
    
    /**
     * Classe de r√©ponse
     */
    public class Response {
        @InvocableVariable
        public Boolean success;
        
        @InvocableVariable
        public String caseId;
        
        @InvocableVariable
        public String message;
        
        public Response(Boolean success, String caseId, String message) {
            this.success = success;
            this.caseId = caseId;
            this.message = message;
        }
    }
    
    /**
     * Classe pour le contexte de diagnostic (public pour les adaptateurs)
     */
    public class DiagnosticContext {
        public ErrorType errorType;
        public String className;
        public String methodName;
        public Integer lineNumber;
        public String sourceCode;
        public String componentName;
        public String jsCode;
        public String metadata;
        public String flowName;
        public String flowApiName;
        public String flowXml;
        public String faultElement;
        public String errorCategory;
    }
    
    /**
     * Classe pour le r√©sultat du diagnostic IA (public pour les adaptateurs)
     */
    public class DiagnosticResult {
        public String problem;
        public String rootCause;
        public String solution;
        public String codeFix;
        public List<String> steps;
        public String severity; // CRITICAL, HIGH, MEDIUM, LOW
    }
    
    /**
     * M√©thode principale invocable depuis Flow
     */
    @InvocableMethod(label='Diagnostic Erreur avec IA' 
                     description='Analyse une erreur (Apex/LWC/Flow) avec IA et cr√©e un Case')
    public static List<Response> diagnoseAndCreateCase(List<ErrorInfo> errors) {
        List<Response> responses = new List<Response>();
        
        for (ErrorInfo error : errors) {
            try {
                // 1. Construire le contexte selon le type
                DiagnosticContext context = buildContext(error);
                
                // 2. Analyser avec IA (prompt sp√©cialis√©)
                DiagnosticResult diagnostic = analyzeWithAI(error, context);
                
                // 3. Cr√©er le Case (l'email sera envoy√© automatiquement par le Case)
                Case newCase = createCase(error, diagnostic, context);
                
                responses.add(new Response(true, newCase.Id, 'Case cr√©√© avec succ√®s'));
                
            } catch (Exception e) {
                System.debug(LoggingLevel.ERROR, 'Erreur lors du diagnostic: ' + e.getMessage());
                System.debug(LoggingLevel.ERROR, 'Stack trace: ' + e.getStackTraceString());
                responses.add(new Response(false, null, 'Erreur: ' + e.getMessage()));
            }
        }
        
        return responses;
    }
    
    /**
     * M√©thode @AuraEnabled pour appels depuis LWC
     */
    @AuraEnabled
    public static String diagnoseLWCError(String componentName, String errorMessage, String stackTrace, String recordId, String objectType, String contextData) {
        System.debug(LoggingLevel.INFO, 'üîß [DIAGNOSTIC APEX] diagnoseLWCError appel√©');
        System.debug(LoggingLevel.INFO, 'üîß [DIAGNOSTIC APEX] Component: ' + componentName);
        System.debug(LoggingLevel.INFO, 'üîß [DIAGNOSTIC APEX] RecordId: ' + recordId);
        
        try {
            ErrorInfo error = new ErrorInfo();
            error.errorType = 'LWC';
            error.componentName = componentName;
            error.errorMessage = errorMessage;
            error.stackTrace = stackTrace != null ? stackTrace : '';
            error.recordId = recordId;
            error.objectType = objectType;
            error.contextData = contextData;
            
            System.debug(LoggingLevel.INFO, 'üîß [DIAGNOSTIC APEX] Appel √† diagnoseAndCreateCase...');
            List<Response> responses = diagnoseAndCreateCase(new List<ErrorInfo>{ error });
            
            System.debug(LoggingLevel.INFO, 'üîß [DIAGNOSTIC APEX] R√©ponses re√ßues: ' + (responses != null ? responses.size() : 0));
            
            if (responses != null && !responses.isEmpty() && responses[0].success) {
                System.debug(LoggingLevel.INFO, '‚úÖ [DIAGNOSTIC APEX] Case cr√©√©: ' + responses[0].caseId);
                return responses[0].caseId;
            } else {
                System.debug(LoggingLevel.WARN, '‚ö†Ô∏è [DIAGNOSTIC APEX] Aucun Case cr√©√© (success=false ou responses vide)');
                return null;
            }
        } catch (Exception e) {
            System.debug(LoggingLevel.ERROR, '‚ùå [DIAGNOSTIC APEX] Erreur lors du diagnostic LWC: ' + e.getMessage());
            System.debug(LoggingLevel.ERROR, '‚ùå [DIAGNOSTIC APEX] StackTrace: ' + e.getStackTraceString());
            throw new AuraHandledException('Erreur lors du diagnostic: ' + e.getMessage());
        }
    }
    
    /**
     * Construit le contexte selon le type d'erreur
     */
    private static DiagnosticContext buildContext(ErrorInfo error) {
        DiagnosticContext context = new DiagnosticContext();
        
        if (error.errorType == 'APEX') {
            context = ApexErrorAdapter.buildContext(error);
        } else if (error.errorType == 'LWC') {
            context = LWCErrorAdapter.buildContext(error);
        } else if (error.errorType == 'FLOW') {
            context = FlowErrorAdapter.buildContext(error);
        }
        
        return context;
    }
    
    /**
     * Analyse avec IA (prompt sp√©cialis√© selon le type)
     */
    private static DiagnosticResult analyzeWithAI(ErrorInfo error, DiagnosticContext context) {
        String prompt = buildPrompt(error, context);
        
        // Appeler OpenAI
        String aiResponse = OpenAI_Service.sendPrompt(prompt);
        
        // ‚úÖ NOUVEAU : Logger la r√©ponse COMPL√àTE pour debug
        System.debug('ü§ñ [DIAGNOSTIC] ===== R√âPONSE IA BRUTE COMPL√àTE =====');
        System.debug(aiResponse);
        System.debug('ü§ñ [DIAGNOSTIC] ===== FIN R√âPONSE IA =====');
        System.debug('ü§ñ [DIAGNOSTIC] Longueur r√©ponse: ' + (aiResponse != null ? aiResponse.length() : 0) + ' caract√®res');
        
        // Parser la r√©ponse
        return parseAIResponse(aiResponse, error);
    }
    
    /**
     * Construit le prompt selon le type d'erreur
     */
    private static String buildPrompt(ErrorInfo error, DiagnosticContext context) {
        if (error.errorType == 'APEX') {
            return ApexErrorAdapter.buildPrompt(error, context);
        } else if (error.errorType == 'LWC') {
            return LWCErrorAdapter.buildPrompt(error, context);
        } else if (error.errorType == 'FLOW') {
            return FlowErrorAdapter.buildPrompt(error, context);
        }
        return '';
    }
    
    /**
     * Parse la r√©ponse OpenAI avec gestion robuste du JSON
     */
    private static DiagnosticResult parseAIResponse(String aiResponse, ErrorInfo error) {
        DiagnosticResult result = new DiagnosticResult();
        
        try {
            // Nettoyer la r√©ponse : enlever les backticks markdown si pr√©sents
            String cleanedResponse = aiResponse.trim();
            
            // Enlever ```json au d√©but
            if (cleanedResponse.startsWith('```json')) {
                cleanedResponse = cleanedResponse.substring(7).trim();
            } else if (cleanedResponse.startsWith('```')) {
                cleanedResponse = cleanedResponse.substring(3).trim();
            }
            
            // Enlever ``` √† la fin
            if (cleanedResponse.endsWith('```')) {
                cleanedResponse = cleanedResponse.substring(0, cleanedResponse.length() - 3).trim();
            }
            
            // Essayer d'extraire le JSON m√™me s'il y a du texte avant/apr√®s
            String jsonString = extractJSON(cleanedResponse);
            
            if (String.isBlank(jsonString)) {
                throw new JSONException('Aucun JSON trouv√© dans la r√©ponse');
            }
            
            // Essayer de parser le JSON nettoy√©
            Map<String, Object> jsonResponse = (Map<String, Object>) JSON.deserializeUntyped(jsonString);
            
            result.problem = (String) jsonResponse.get('problem');
            result.rootCause = (String) jsonResponse.get('rootCause');
            result.solution = (String) jsonResponse.get('solution');
            result.codeFix = (String) jsonResponse.get('codeFix');
            result.severity = (String) jsonResponse.get('severity');
            
            // Parser les steps
            if (jsonResponse.containsKey('steps')) {
                List<Object> stepsObj = (List<Object>) jsonResponse.get('steps');
                result.steps = new List<String>();
                for (Object step : stepsObj) {
                    result.steps.add(String.valueOf(step));
                }
            }
            
            System.debug(LoggingLevel.INFO, '‚úÖ [DIAGNOSTIC] JSON pars√© avec succ√®s');
            
        } catch (Exception e) {
            // Si le parsing √©choue, essayer d'extraire les informations manuellement
            System.debug(LoggingLevel.WARN, '‚ö†Ô∏è [DIAGNOSTIC] Erreur parsing JSON: ' + e.getMessage());
            System.debug(LoggingLevel.WARN, '‚ö†Ô∏è [DIAGNOSTIC] StackTrace: ' + e.getStackTraceString());
            
            // Essayer d'extraire les champs manuellement avec regex
            result = extractFieldsManually(aiResponse, error);
        }
        
        // Valeurs par d√©faut si manquantes
        if (String.isBlank(result.severity)) {
            result.severity = 'MEDIUM';
        }
        if (result.steps == null) {
            result.steps = new List<String>();
        }
        
        return result;
    }
    
    /**
     * Extrait le JSON d'une cha√Æne qui peut contenir du texte avant/apr√®s
     */
    private static String extractJSON(String input) {
        // Chercher le premier { et le dernier } √©quilibr√©
        Integer startIdx = input.indexOf('{');
        if (startIdx == -1) {
            return null;
        }
        
        // Compter les accolades pour trouver la fin du JSON
        Integer braceCount = 0;
        Integer endIdx = -1;
        
        for (Integer i = startIdx; i < input.length(); i++) {
            String charAt = input.substring(i, i + 1);
            if (charAt == '{') {
                braceCount++;
            } else if (charAt == '}') {
                braceCount--;
                if (braceCount == 0) {
                    endIdx = i;
                    break;
                }
            }
        }
        
        if (endIdx == -1) {
            return null;
        }
        
        return input.substring(startIdx, endIdx + 1);
    }
    
    /**
     * Extrait les champs manuellement si le parsing JSON √©choue
     */
    private static DiagnosticResult extractFieldsManually(String aiResponse, ErrorInfo error) {
        DiagnosticResult result = new DiagnosticResult();
        
        // Essayer d'extraire les champs avec des patterns regex simples
        Pattern problemPattern = Pattern.compile('"problem"\\s*:\\s*"([^"]+)"');
        Pattern rootCausePattern = Pattern.compile('"rootCause"\\s*:\\s*"([^"]+)"');
        Pattern solutionPattern = Pattern.compile('"solution"\\s*:\\s*"([^"]+)"');
        Pattern severityPattern = Pattern.compile('"severity"\\s*:\\s*"([^"]+)"');
        
        Matcher problemMatcher = problemPattern.matcher(aiResponse);
        if (problemMatcher.find()) {
            result.problem = problemMatcher.group(1);
        }
        
        Matcher rootCauseMatcher = rootCausePattern.matcher(aiResponse);
        if (rootCauseMatcher.find()) {
            result.rootCause = rootCauseMatcher.group(1);
        }
        
        Matcher solutionMatcher = solutionPattern.matcher(aiResponse);
        if (solutionMatcher.find()) {
            result.solution = solutionMatcher.group(1);
        }
        
        Matcher severityMatcher = severityPattern.matcher(aiResponse);
        if (severityMatcher.find()) {
            result.severity = severityMatcher.group(1);
        }
        
        // Extraire codeFix (peut contenir plusieurs lignes et backticks)
        // Note: Apex Pattern ne supporte pas MULTILINE/DOTALL, on utilise une approche diff√©rente
        Pattern codeFixPattern = Pattern.compile('"codeFix"\\s*:\\s*"([^"]*(?:\\\\.[^"]*)*)"');
        Matcher codeFixMatcher = codeFixPattern.matcher(aiResponse);
        if (codeFixMatcher.find()) {
            result.codeFix = codeFixMatcher.group(1).replace('\\n', '\n').replace('\\"', '"');
        } else {
            // Essayer d'extraire le code entre backticks apr√®s "codeFix"
            Pattern codeFixAltPattern = Pattern.compile('"codeFix"\\s*:\\s*"([^"]*)"');
            Matcher codeFixAltMatcher = codeFixAltPattern.matcher(aiResponse);
            if (codeFixAltMatcher.find()) {
                result.codeFix = codeFixAltMatcher.group(1);
            }
        }
        
        // Si toujours rien trouv√©, utiliser la r√©ponse brute
        if (String.isBlank(result.problem)) {
            result.problem = 'Erreur lors du parsing de la r√©ponse IA';
            result.rootCause = error.errorMessage;
            result.solution = aiResponse.length() > 10000 ? aiResponse.substring(0, 10000) + '...' : aiResponse;
            result.severity = 'MEDIUM';
            result.steps = new List<String>{ 'V√©rifier manuellement la r√©ponse IA dans le Case' };
        }
        
        return result;
    }
    
    /**
     * Cr√©e un Case avec toutes les informations
     * L'email sera envoy√© automatiquement par un Flow/Trigger sur Case
     */
    private static Case createCase(ErrorInfo error, DiagnosticResult diagnostic, DiagnosticContext context) {
        Case newCase = new Case();
        
        // Informations de base
        newCase.Subject = '[' + error.errorType + ' ERROR] ' + 
                         (String.isNotBlank(error.componentName) ? error.componentName : 'Erreur') + 
                         ' - ' + diagnostic.severity;
        
        newCase.Description = buildCaseDescription(error, diagnostic, context);
        newCase.Priority = mapSeverityToPriority(diagnostic.severity);
        newCase.Status = 'New';
        newCase.Origin = 'Automated';
        
        // Type d'erreur dans la description (pour filtrage)
        newCase.Type = error.errorType;
        
        // ‚úÖ RecordType Debug
        newCase.RecordTypeId = Schema.SObjectType.Case.getRecordTypeInfosByDeveloperName().get('Debug').getRecordTypeId();
        
        // ‚úÖ NOUVEAU: Champs custom pour debug
        newCase.put('Error_Source__c', error.errorType);
        newCase.put('Component__c', error.errorType == 'LWC' ? error.componentName : error.errorType == 'APEX' ? error.className : error.flowName);
        newCase.put('Method__c', error.methodName);
        newCase.put('Severity__c', diagnostic.severity);
        newCase.put('User__c', UserInfo.getUserId());
        newCase.put('Error_Message__c', error.errorMessage);
        newCase.put('Raw_Error__c', error.stackTrace);
        newCase.put('Context__c', error.contextData);
        newCase.put('Error_Json__c', JSON.serializePretty(diagnostic));
        newCase.put('Error_Signature__c', generateErrorSignature(error));
        newCase.put('Environment__c', getEnvironment());
        newCase.put('Release_Tag__c', getReleaseTag());
        
        // Assigner √† l'admin (r√©cup√©rer depuis Custom Metadata ou User)
        newCase.OwnerId = getAdminUserId();

        // ‚úÖ AM√âLIORATION v2.3: Lier au record (Account uniquement pour l'instant)
        // Note: WhatId pourrait √™tre utilis√© pour Quote/Opportunity si support√© par l'org
        if (String.isNotBlank(error.recordId) && error.objectType == 'Account') {
            try {
                newCase.AccountId = error.recordId;
                System.debug(LoggingLevel.INFO, '‚úÖ [DIAGNOSTIC] AccountId d√©fini: ' + error.recordId);
            } catch (Exception e) {
                System.debug(LoggingLevel.WARN, '‚ö†Ô∏è [DIAGNOSTIC] Impossible de lier AccountId: ' + e.getMessage());
            }
        }
        
        insert newCase;
        
        // Poster le diagnostic dans le Feed du Case
        postDiagnosticToFeed(newCase.Id, error, diagnostic, context);
        
        return newCase;
    }
    
    /**
     * Poste le diagnostic IA dans le Feed du Case
     */
    private static void postDiagnosticToFeed(Id caseId, ErrorInfo error, DiagnosticResult diagnostic, DiagnosticContext context) {
        try {
            // Construire le message pour le feed (format plus concis)
            String feedMessage = buildFeedMessage(error, diagnostic, context);
            
            // Cr√©er le post via ConnectApi
            ConnectApi.FeedItemInput feedItemInput = new ConnectApi.FeedItemInput();
            ConnectApi.MessageBodyInput messageBodyInput = new ConnectApi.MessageBodyInput();
            ConnectApi.TextSegmentInput textSegmentInput = new ConnectApi.TextSegmentInput();
            
            textSegmentInput.text = feedMessage;
            messageBodyInput.messageSegments = new List<ConnectApi.MessageSegmentInput>{ textSegmentInput };
            feedItemInput.body = messageBodyInput;
            feedItemInput.subjectId = caseId;
            
            ConnectApi.FeedElement feedElement = ConnectApi.ChatterFeeds.postFeedElement(
                Network.getNetworkId(),
                feedItemInput
            );
            
            System.debug(LoggingLevel.INFO, '‚úÖ [DIAGNOSTIC] Post cr√©√© dans le Feed: ' + feedElement.id);
            
        } catch (Exception e) {
            // Ne pas faire √©chouer la cr√©ation du Case si le post √©choue
            System.debug(LoggingLevel.ERROR, '‚ùå [DIAGNOSTIC] Erreur lors de la cr√©ation du post Feed: ' + e.getMessage());
            System.debug(LoggingLevel.ERROR, '‚ùå [DIAGNOSTIC] StackTrace: ' + e.getStackTraceString());
        }
    }
    
    /**
     * Construit le message pour le Feed (format concis)
     */
    private static String buildFeedMessage(ErrorInfo error, DiagnosticResult diagnostic, DiagnosticContext context) {
        // ‚úÖ NOUVEAU v2.3: Template optimis√© selon suggestions GPT
        String message = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
        message += 'üß† **DIAGNOSTIC IA AUTOMATIQUE**\n';
        message += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';

        // Informations essentielles en une ligne
        message += '**Type:** ' + error.errorType;
        
        if (error.errorType == 'LWC' && String.isNotBlank(error.componentName)) {
            message += ' | **Composant:** ' + error.componentName;
            if (String.isNotBlank(error.methodName)) {
                message += ' | **M√©thode:** ' + error.methodName;
            }
        } else if (error.errorType == 'APEX' && String.isNotBlank(error.className)) {
            message += ' | **Classe:** ' + error.className;
            if (String.isNotBlank(error.methodName)) {
                message += ' | **M√©thode:** ' + error.methodName;
            }
        } else if (error.errorType == 'FLOW' && String.isNotBlank(error.flowName)) {
            message += ' | **Flow:** ' + error.flowName;
        }
        message += '\n';

        if (String.isNotBlank(error.recordId)) {
            message += '**Record:** ' + error.objectType + ' (' + error.recordId + ')\n';
        }
        
        // ‚úÖ NOUVEAU: Ajouter User info
        message += '**User:** ' + UserInfo.getName() + ' (' + UserInfo.getUserEmail() + ')\n';
        message += '\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';

        message += '‚ùó **Probl√®me**\n\n' + diagnostic.problem + '\n\n';
        message += 'üîç **Cause Racine**\n\n' + diagnostic.rootCause + '\n\n';
        message += 'üõ†Ô∏è **Solution Recommand√©e**\n\n' + diagnostic.solution;

        if (String.isNotBlank(diagnostic.codeFix)) {
            message += '\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';
            message += 'üß© **Correctif Propos√©**\n\n```\n' + diagnostic.codeFix + '\n```';
        }

        if (diagnostic.steps != null && !diagnostic.steps.isEmpty()) {
            message += '\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n';
            message += 'üìã **√âtapes de Correction**\n\n';
            Integer stepNum = 1;
            for (String step : diagnostic.steps) {
                message += stepNum + '. ' + step + '\n';
                stepNum++;
            }
        }
        
        message += '\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
        message += 'üí° *Diagnostic g√©n√©r√© automatiquement par Azure OpenAI + ErrorDiagnosticService*\n';
        message += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
        
        // Limiter √† 10000 caract√®res (limite max Salesforce FeedItem.Body)
        if (message.length() > 10000) {
            message = message.substring(0, 9997) + '...';
        }
        
        return message;
    }
    
    /**
     * Construit la description compl√®te du Case
     */
    private static String buildCaseDescription(ErrorInfo error, DiagnosticResult diagnostic, DiagnosticContext context) {
        // ‚úÖ NOUVEAU v2.3: Description structur√©e selon template GPT
        String description = '=== TECH INFO ===\n\n';
        
        description += 'Source: ' + error.errorType + '\n';

        if (error.errorType == 'APEX') {
            description += 'Component: ' + (String.isNotBlank(error.className) ? error.className : 'N/A') + '\n';
            description += 'Method: ' + (String.isNotBlank(error.methodName) ? error.methodName : 'N/A') + '\n';
            if (error.lineNumber != null) {
                description += 'Line: ' + error.lineNumber + '\n';
            }
        } else if (error.errorType == 'LWC') {
            description += 'Component: ' + (String.isNotBlank(error.componentName) ? error.componentName : 'N/A') + '\n';
            description += 'Method: ' + (String.isNotBlank(error.methodName) ? error.methodName : 'N/A') + '\n';
        } else if (error.errorType == 'FLOW') {
            description += 'Flow: ' + (String.isNotBlank(error.flowName) ? error.flowName : 'N/A') + '\n';
            description += 'API Name: ' + (String.isNotBlank(error.flowApiName) ? error.flowApiName : 'N/A') + '\n';
            if (String.isNotBlank(error.faultElement)) {
                description += 'Failed Element: ' + error.faultElement + '\n';
            }
        }

        if (String.isNotBlank(error.recordId)) {
            description += 'Record: ' + error.objectType + ' (' + error.recordId + ')\n';
        }
        
        description += 'User: ' + UserInfo.getName() + ' (' + UserInfo.getUserEmail() + ')\n';
        description += 'Date: ' + Datetime.now().format('yyyy-MM-dd HH:mm:ss') + '\n\n';
        
        description += '=== ERROR ===\n\n';
        description += 'Message: ' + error.errorMessage + '\n\n';

        if (String.isNotBlank(error.stackTrace)) {
            description += 'Stacktrace (first 1000 chars):\n' + error.stackTrace.left(1000) + '\n\n';
        }
        
        description += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
        description += 'üí° Diagnostic IA disponible dans le Feed du Case\n';
        description += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
        
        return description;
    }
    
    /**
     * Utilitaires
     */
    private static String mapSeverityToPriority(String severity) {
        if (severity == 'CRITICAL') return 'High';
        if (severity == 'HIGH') return 'High';
        if (severity == 'MEDIUM') return 'Medium';
        return 'Low';
    }
    
    /**
     * G√©n√®re une signature unique pour regrouper les erreurs identiques
     */
    private static String generateErrorSignature(ErrorInfo error) {
        String signature = error.errorType + '|' + 
                          (String.isNotBlank(error.componentName) ? error.componentName : error.className) + '|' +
                          (String.isNotBlank(error.methodName) ? error.methodName : '') + '|' +
                          (String.isNotBlank(error.errorMessage) ? error.errorMessage.left(100) : '');
        return EncodingUtil.convertToHex(Crypto.generateDigest('MD5', Blob.valueOf(signature))).left(40);
    }
    
    /**
     * D√©tecte l'environnement (DEV/UAT/PROD) selon l'org
     */
    private static String getEnvironment() {
        String orgId = UserInfo.getOrganizationId();
        String orgName = UserInfo.getOrganizationName();
        
        // D√©tecter selon le nom de l'org ou l'ID
        if (orgName.containsIgnoreCase('sandbox') || orgName.containsIgnoreCase('dev')) {
            return 'DEV';
        } else if (orgName.containsIgnoreCase('uat') || orgName.containsIgnoreCase('preprod')) {
            return 'UAT';
        }
        
        // Par d√©faut: PROD
        return 'PROD';
    }
    
    /**
     * R√©cup√®re le tag de release (√† personnaliser selon votre CI/CD)
     */
    private static String getReleaseTag() {
        // TODO: Int√©grer avec votre syst√®me CI/CD pour r√©cup√©rer le tag
        // Pour l'instant, retourner une version bas√©e sur la date
        return 'v' + Datetime.now().format('yyyy.MM.dd');
    }
    
    private static Id getAdminUserId() {
        // R√©cup√©rer depuis Custom Metadata ou User
        // Exemple: User admin = [SELECT Id FROM User WHERE Email = 'admin@example.com' LIMIT 1];
        // return admin.Id;
        
        // Par d√©faut: User actuel ou Queue
        return UserInfo.getUserId(); // √Ä adapter selon tes besoins
    }
}
